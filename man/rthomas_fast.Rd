% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/thomas_fast.R
\name{rthomas_fast}
\alias{rthomas_fast}
\title{Fast Thomas Process (Rcpp-backed) in an arbitrary polygon}
\usage{
rthomas_fast(
  domain,
  n_target,
  kappa = NULL,
  mu = 10,
  sigma = 1,
  oversample = 1.3
)
}
\arguments{
\item{domain}{An \pkg{sf} polygon/multipolygon defining the study area (projected CRS recommended).}

\item{n_target}{Integer, desired number of retained points inside \code{domain}.}

\item{kappa}{Optional parent intensity (parents per unit area). If \code{NULL},
it is derived from \code{n_target}, \code{mu}, and domain area.}

\item{mu}{Mean offspring per parent (Poisson).}

\item{sigma}{Gaussian cluster scale (standard deviation of offspring displacement; map units).}

\item{oversample}{Scalar \eqn{> 1}. Multiplier used to request enough raw
offspring in the bbox so that, after polygon filtering, you still retain
about \code{n_target}. Default \code{1.3}.}
}
\value{
An \pkg{sf} POINT layer with exactly \code{n_target} rows (if feasible),
or fewer if \code{kappa}/\code{mu} are too small to generate enough points.
}
\description{
Simulate \eqn{n\_target} points from a Thomas (Gaussian Neyman–Scott) process,
using a fast C++ generator in the domain's bounding box and then filtering to
the polygon with \pkg{sf}. This is a drop-in replacement for the spatstat-based
Thomas simulator and is substantially faster for large simulations.
}
\details{
Let \eqn{A_D} be the polygon area and \eqn{A_B} its bbox area. The expected fraction
of bbox points that survive the polygon filter is \eqn{f \approx A_D / A_B}. We request roughly
\code{n_target / f} points from C++ (times \code{oversample}), then filter, and finally
thin or (if short) resample with replacement to return exactly \code{n_target}. If you prefer
strict “no replacement”, set \code{oversample} higher or supply a larger \code{kappa}.
}
\examples{
\dontrun{
dom <- create_sampling_domain()
pts <- rthomas_fast(dom, n_target = 2000, mu = 10, sigma = 1)
plot(sf::st_geometry(pts), pch = 16, cex = 0.4)
}
}
